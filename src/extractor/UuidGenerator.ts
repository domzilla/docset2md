import { createHash } from 'node:crypto';

/**
 * Generate a UUID for cache lookup from a request key.
 *
 * The UUID is generated by:
 * 1. Creating a canonical path from the request key
 * 2. Computing SHA-1 hash of the path
 * 3. Truncating to first 6 bytes
 * 4. Base64url encoding
 * 5. Prepending language prefix
 */
export function generateUuid(requestKey: string): string {
  // Determine language prefix and extract canonical path
  let prefix: string;
  let canonicalPath: string;

  if (requestKey.startsWith('ls/')) {
    prefix = 'ls';
    canonicalPath = '/' + requestKey.slice(3);
  } else if (requestKey.startsWith('lc/')) {
    prefix = 'lc';
    canonicalPath = '/' + requestKey.slice(3);
  } else {
    throw new Error(`Invalid request key format: ${requestKey}`);
  }

  // Compute SHA-1 hash
  const hash = createHash('sha1').update(canonicalPath).digest();

  // Truncate to first 6 bytes and encode as base64url
  const truncated = hash.subarray(0, 6);
  const suffix = truncated.toString('base64url');

  return prefix + suffix;
}

/**
 * Extract the documentation path from a request key.
 * e.g., "ls/documentation/accelerate" -> "/documentation/accelerate"
 */
export function getDocPath(requestKey: string): string {
  if (requestKey.startsWith('ls/') || requestKey.startsWith('lc/')) {
    return '/' + requestKey.slice(3);
  }
  return '/' + requestKey;
}

/**
 * Extract framework name from a request key.
 * e.g., "ls/documentation/accelerate/vdsp" -> "accelerate"
 */
export function extractFramework(requestKey: string): string | undefined {
  const match = requestKey.match(/l[sc]\/documentation\/([^/]+)/);
  return match?.[1];
}

/**
 * Get the language from a request key.
 */
export function getLanguage(requestKey: string): 'swift' | 'objc' {
  return requestKey.startsWith('ls/') ? 'swift' : 'objc';
}
